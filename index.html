<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tra c·ª©u Loyalty ‚Äì CT 2026</title>

<style>
    * { box-sizing: border-box; }
    body { 
        font-family: 'Segoe UI', Tahoma, Arial, sans-serif; 
        padding: 20px; 
        background: #f5f5f5;
        margin: 0;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    h2 { 
        color: #333; 
        margin-bottom: 20px;
        font-size: 24px;
    }
    
    .search-box {
        margin-bottom: 20px;
    }
    
    .filter-box {
        margin-bottom: 20px;
        padding: 15px;
        background: #f9f9f9;
        border-radius: 6px;
    }
    
    .filter-box label {
        margin-right: 15px;
        cursor: pointer;
        font-size: 14px;
    }
    
    .filter-box input[type="radio"] {
        margin-right: 5px;
        cursor: pointer;
    }
    
    input[type="text"] { 
        width: 100%;
        max-width: 500px;
        padding: 12px 16px; 
        font-size: 15px;
        border: 2px solid #ddd;
        border-radius: 6px;
        transition: border-color 0.3s;
    }
    
    input[type="text"]:focus {
        outline: none;
        border-color: #4CAF50;
    }
    
    .stats {
        margin: 15px 0;
        padding: 12px;
        background: #e3f2fd;
        border-radius: 6px;
        font-size: 14px;
        color: #1976d2;
    }
    
    .table-wrapper {
        overflow-x: auto;
        margin-top: 20px;
    }
    
    table { 
        border-collapse: collapse; 
        width: 100%; 
        background: #fff;
        font-size: 13px;
    }
    
    th, td { 
        border: 1px solid #ddd; 
        padding: 10px 8px;
        text-align: left;
    }
    
    th { 
        background: #4CAF50;
        color: white;
        font-weight: 600;
        position: sticky; 
        top: 0;
        z-index: 10;
    }
    
    tr.ok { 
        background: #e8f5e9; 
    }
    
    tr.missing { 
        background: #ffebee; 
    }
    
    tr.pending {
        background: #fff9c4;
    }
    
    tr:hover {
        background: #f5f5f5 !important;
    }
    
    .status-ok {
        color: #2e7d32;
        font-weight: 600;
    }
    
    .status-missing {
        color: #c62828;
        font-weight: 600;
    }
    
    .status-pending {
        color: #f57c00;
        font-weight: 600;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        color: #666;
        font-size: 16px;
    }
    
    .no-results {
        text-align: center;
        padding: 40px;
        color: #999;
        font-style: italic;
    }
</style>
</head>

<body>

<div class="container">
    <h2>üîç Tra c·ª©u kh√°ch h√†ng Loyalty ‚Äì Ki·ªÉm tra CT 2026</h2>
    
    <div class="search-box">
        <input 
            type="text"
            id="searchInput" 
            placeholder="Nh·∫≠p M√£ KH / T√™n kh√°ch h√†ng / SƒêT / T√™n TDV ƒë·ªÉ t√¨m ki·∫øm..."
            autocomplete="off"
        >
    </div>
    
    <div class="filter-box">
        <strong>L·ªçc tr·∫°ng th√°i:</strong>
        <label>
            <input type="radio" name="statusFilter" value="all" checked> T·∫•t c·∫£
        </label>
        <label>
            <input type="radio" name="statusFilter" value="ok"> ‚úÖ ƒê√£ tham gia
        </label>
        <label>
            <input type="radio" name="statusFilter" value="missing"> ‚ùå Ch∆∞a tham gia
        </label>
        <label>
            <input type="radio" name="statusFilter" value="pending"> ‚ùì ƒê√£ upload ch∆∞a ki·ªÉm tra
        </label>
    </div>
    
    <div id="stats" class="stats" style="display:none;"></div>
    
    <div class="table-wrapper">
        <table>
            <thead>
                <tr>
                    <th>M√£ KH</th>
                    <th>Kh√°ch h√†ng</th>
                    <th>T·ªânh</th>
                    <th>SƒêT</th>
                    <th>TDV</th>
                    <th>Team k√Ω 2025</th>
                    <th>Team k√Ω 2026</th>
                    <th>ƒêƒÉng k√Ω th√†nh c√¥ng</th>
                    <th>Ghi ch√∫</th>
                    <th>Tr·∫°ng th√°i 2026</th>
                </tr>
            </thead>
            <tbody id="tbody">
                <tr>
                    <td colspan="10" class="loading">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu...</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
const NEW_URL = "https://docs.google.com/spreadsheets/d/14dZ70xuUlYskJHGLfF4dI_lY_V8vsqJfAJ-Dlo_DdrU/gviz/tq?tqx=out:json&sheet=new_data&tq=select%20*%20limit%2020000";
const OLD_URL = "https://docs.google.com/spreadsheets/d/14dZ70xuUlYskJHGLfF4dI_lY_V8vsqJfAJ-Dlo_DdrU/gviz/tq?tqx=out:json&sheet=original_data&tq=select%20*%20limit%2020000";
const UPDATE_URL = "https://docs.google.com/spreadsheets/d/14dZ70xuUlYskJHGLfF4dI_lY_V8vsqJfAJ-Dlo_DdrU/gviz/tq?tqx=out:json&sheet=bc_loyalty&tq=select%20*%20limit%2020000";

const MAX_RENDER = 10000;

let allData = [];
let uniqueData = [];
let debounceTimer;
let isLoading = true;
let currentFilter = 'all';

/* ===== PARSE GOOGLE VISUALIZATION JSON ===== */
function parseGViz(text) {
    const jsonText = text.substring(47, text.length - 2);
    return JSON.parse(jsonText);
}

function normalizeValue(val) {
    if (val === null || val === undefined || val === "") return "";
    return String(val).trim();
}

function rowToObject(cols, row) {
    const obj = {};
    cols.forEach((col, i) => {
        const cellValue = row.c[i];
        let value = "";
        
        if (cellValue !== null && cellValue !== undefined) {
            if (cellValue.v !== null && cellValue.v !== undefined) {
                value = cellValue.v;
            }
        }
        
        obj[col.label] = value;
    });
    return obj;
}

/* ===== CREATE UNIQUE KEY FOR DEDUPLICATION ===== */
function createUniqueKey(kh, sdt) {
    const khNorm = normalizeValue(kh).toLowerCase().replace(/\s+/g, '');
    const sdtNorm = normalizeValue(sdt).replace(/\s+/g, '');
    return `${khNorm}|${sdtNorm}`;
}

/* ===== PARSE DATETIME FROM NGAY COLUMN ===== */
function parseNgayColumn(ngayStr) {
    if (!ngayStr) return null;
    try {
        // Format: 2025-12-18 16:00:02.653
        const str = normalizeValue(ngayStr);
        if (!str) return null;
        
        // Parse datetime string
        const date = new Date(str);
        if (isNaN(date.getTime())) return null;
        
        return date;
    } catch (e) {
        return null;
    }
}

/* ===== CHECK CUSTOMER STATUS IN 2026 ===== */
function getCustomerStatus(data) {
    // N·∫øu data t·ª´ bc_loyalty sheet
    if (data._isUpdate) {
        return "pending"; // ‚ùìƒê√£ upload ch∆∞a ki·ªÉm tra
    }
    
    // N·∫øu t·ª´ new_data ho·∫∑c original_data
    const dangKy = normalizeValue(data["ƒêƒÉng k√Ω th√†nh c√¥ng"]).toUpperCase();
    return dangKy === "OK" ? "ok" : "missing";
}

/* ===== LOAD DATA ===== */
async function loadData() {
    try {
        const [newResponse, oldResponse, updateResponse] = await Promise.all([
            fetch(NEW_URL),
            fetch(OLD_URL),
            fetch(UPDATE_URL)
        ]);

        const newText = await newResponse.text();
        const oldText = await oldResponse.text();
        const updateText = await updateResponse.text();

        const newJson = parseGViz(newText);
        const oldJson = parseGViz(oldText);
        const updateJson = parseGViz(updateText);

        console.log("=== DEBUG INFO ===");
        console.log("New data rows:", newJson.table.rows.length);
        console.log("Old data rows:", oldJson.table.rows.length);
        console.log("Update data rows:", updateJson.table.rows.length);

        // Process new_data
        const newDataArray = [];
        newJson.table.rows.forEach(row => {
            const obj = rowToObject(newJson.table.cols, row);
            
            const maKH = normalizeValue(obj["M√£ KH"]);
            const sdt = normalizeValue(obj["S·ªë ƒëi·ªán tho·∫°i di ƒë·ªông"]);
            const kh = normalizeValue(obj["KH"]);
            const tdv = normalizeValue(obj["TDV"]);
            
            obj._search = [maKH, kh, sdt, tdv].join(" ").toLowerCase();
            obj._isNew = true;
            obj._isUpdate = false;
            obj._uniqueKey = createUniqueKey(kh, sdt);
            
            newDataArray.push(obj);
        });

        // Process original_data
        const oldDataArray = [];
        oldJson.table.rows.forEach(row => {
            const obj = rowToObject(oldJson.table.cols, row);
            
            const maKH = normalizeValue(obj["M√£ KH"]);
            const sdt = normalizeValue(obj["S·ªë ƒëi·ªán tho·∫°i di ƒë·ªông"]);
            const kh = normalizeValue(obj["KH"]);
            const tdv = normalizeValue(obj["TDV"]);
            
            obj._search = [maKH, kh, sdt, tdv].join(" ").toLowerCase();
            obj._isNew = false;
            obj._isUpdate = false;
            obj._uniqueKey = createUniqueKey(kh, sdt);
            
            oldDataArray.push(obj);
        });

        // Process bc_loyalty (update data)
        const updateDataArray = [];
        updateJson.table.rows.forEach(row => {
            const obj = rowToObject(updateJson.table.cols, row);
            
            const maKH = normalizeValue(obj["M√£ KH"]);
            const sdt = normalizeValue(obj["S·ªë ƒëi·ªán tho·∫°i di ƒë·ªông"]);
            const kh = normalizeValue(obj["KH"]);
            const tdv = normalizeValue(obj["TDV"]);
            const ngay = normalizeValue(obj["NGAY"]);
            
            obj._search = [maKH, kh, sdt, tdv].join(" ").toLowerCase();
            obj._isNew = false;
            obj._isUpdate = true; // ƒê√°nh d·∫•u l√† t·ª´ bc_loyalty
            obj._uniqueKey = createUniqueKey(kh, sdt);
            obj._ngayDate = parseNgayColumn(ngay); // Parse date for sorting
            
            updateDataArray.push(obj);
        });

        // Merge v√† lo·∫°i b·ªè tr√πng l·∫∑p d·ª±a tr√™n KH + SƒêT
        // ∆Øu ti√™n: new_data > bc_loyalty > original_data
        // V·ªõi bc_loyalty: n·∫øu c√≥ nhi·ªÅu b·∫£n ghi c√πng KH+SƒêT, l·∫•y b·∫£n ƒëƒÉng k√Ω s·ªõm nh·∫•t (NGAY nh·ªè nh·∫•t)
        const dataMap = new Map();
        
        // Th√™m old data tr∆∞·ªõc (∆∞u ti√™n th·∫•p nh·∫•t)
        oldDataArray.forEach(item => {
            if (item._uniqueKey) {
                dataMap.set(item._uniqueKey, item);
            }
        });
        
        // Th√™m update data (bc_loyalty) - ∆∞u ti√™n trung b√¨nh
        // N·∫øu c√≥ nhi·ªÅu b·∫£n ghi c√πng uniqueKey, ch·ªâ l·∫•y b·∫£n c√≥ NGAY s·ªõm nh·∫•t
        updateDataArray.forEach(item => {
            if (item._uniqueKey) {
                const existing = dataMap.get(item._uniqueKey);
                
                // N·∫øu ch∆∞a c√≥ ho·∫∑c existing kh√¥ng ph·∫£i t·ª´ bc_loyalty, th√™m v√†o
                if (!existing || !existing._isUpdate) {
                    dataMap.set(item._uniqueKey, item);
                } else {
                    // C·∫£ hai ƒë·ªÅu t·ª´ bc_loyalty, so s√°nh ng√†y
                    if (item._ngayDate && existing._ngayDate) {
                        // L·∫•y b·∫£n c√≥ ng√†y s·ªõm h∆°n
                        if (item._ngayDate < existing._ngayDate) {
                            dataMap.set(item._uniqueKey, item);
                        }
                    } else if (item._ngayDate && !existing._ngayDate) {
                        // Item c√≥ ng√†y, existing kh√¥ng c√≥, ∆∞u ti√™n item
                        dataMap.set(item._uniqueKey, item);
                    }
                    // N·∫øu existing c√≥ ng√†y m√† item kh√¥ng c√≥, gi·ªØ existing
                }
            }
        });
        
        // Th√™m new data cu·ªëi c√πng (∆∞u ti√™n cao nh·∫•t - s·∫Ω ghi ƒë√® m·ªçi th·ª©)
        newDataArray.forEach(item => {
            if (item._uniqueKey) {
                dataMap.set(item._uniqueKey, item);
            }
        });
        
        uniqueData = Array.from(dataMap.values());
        
        const totalRaw = newDataArray.length + oldDataArray.length + updateDataArray.length;
        console.log("Total raw data:", totalRaw);
        console.log("Unique data after deduplication:", uniqueData.length);
        console.log("Duplicates removed:", totalRaw - uniqueData.length);
        console.log("Priority order: new_data > bc_loyalty (earliest NGAY) > original_data");

        isLoading = false;
        showMessage(`‚úÖ ƒê√£ t·∫£i ${uniqueData.length} kh√°ch h√†ng duy nh·∫•t (t·ª´ ${newDataArray.length} new + ${updateDataArray.length} update + ${oldDataArray.length} old, ƒë√£ lo·∫°i b·ªè ${totalRaw - uniqueData.length} b·∫£n ghi tr√πng). ∆Øu ti√™n: new_data > bc_loyalty (ƒëƒÉng k√Ω s·ªõm nh·∫•t) > original_data. H√£y nh·∫≠p t·ª´ kh√≥a ƒë·ªÉ t√¨m ki·∫øm.`);
        
    } catch (error) {
        isLoading = false;
        showMessage("‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i sau.");
        console.error("Load error:", error);
    }
}

/* ===== RENDER TABLE ===== */
function render(keyword = "") {
    const tbody = document.getElementById("tbody");
    const statsDiv = document.getElementById("stats");
    
    if (isLoading) {
        return;
    }

    if (!keyword.trim()) {
        tbody.innerHTML = '<tr><td colspan="10" class="no-results">üëÜ Nh·∫≠p t·ª´ kh√≥a ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm</td></tr>';
        statsDiv.style.display = "none";
        return;
    }

    const kw = keyword.toLowerCase().trim();
    const fragment = document.createDocumentFragment();
    let count = 0;
    let okCount = 0;
    let missingCount = 0;
    let pendingCount = 0;

    for (const data of uniqueData) {
        if (!data._search.includes(kw)) continue;

        const status = getCustomerStatus(data);
        
        // Apply status filter
        if (currentFilter === 'ok' && status !== 'ok') continue;
        if (currentFilter === 'missing' && status !== 'missing') continue;
        if (currentFilter === 'pending' && status !== 'pending') continue;

        const tr = document.createElement("tr");
        const maKH = normalizeValue(data["M√£ KH"]);
        
        if (status === 'ok') {
            tr.className = "ok";
            okCount++;
        } else if (status === 'pending') {
            tr.className = "pending";
            pendingCount++;
        } else {
            tr.className = "missing";
            missingCount++;
        }

        const teamKy2025 = normalizeValue(data["TEAM ƒê√É K√ù 2025"]);
        const teamKy2026 = normalizeValue(data["TEAM K√ù 2026"]);
        const dangKyThanhCong = normalizeValue(data["ƒêƒÉng k√Ω th√†nh c√¥ng"]);
        
        const noteHinhAnh = normalizeValue(data["Note h√¨nh ·∫£nh"]);
        const thongTinSai = normalizeValue(data["Th√¥ng tin sai/thi·∫øu (n·∫øu c√≥)"]);
        const note = [noteHinhAnh, thongTinSai].filter(n => n).join(" | ");

        const sdt = normalizeValue(data["S·ªë ƒëi·ªán tho·∫°i di ƒë·ªông"]);
        const khachHang = normalizeValue(data["KH"]);
        const tinh = normalizeValue(data["T·ªânh"]);
        const tdvName = normalizeValue(data["TDV"]);

        let statusDisplay, statusClass;
        if (status === 'ok') {
            statusDisplay = "‚úÖ ƒê√£ tham gia";
            statusClass = "status-ok";
        } else if (status === 'pending') {
            statusDisplay = "‚ùì ƒê√£ upload ch∆∞a ki·ªÉm tra";
            statusClass = "status-pending";
        } else {
            statusDisplay = "‚ùå Ch∆∞a tham gia";
            statusClass = "status-missing";
        }

        tr.innerHTML = `
            <td>${maKH}</td>
            <td>${khachHang}</td>
            <td>${tinh}</td>
            <td>${sdt}</td>
            <td>${tdvName}</td>
            <td>${teamKy2025}</td>
            <td>${teamKy2026}</td>
            <td>${dangKyThanhCong}</td>
            <td>${note}</td>
            <td class="${statusClass}">
                ${statusDisplay}
            </td>
        `;

        fragment.appendChild(tr);
        count++;
        
        if (count >= MAX_RENDER) break;
    }

    if (count === 0) {
        tbody.innerHTML = '<tr><td colspan="10" class="no-results">üîç Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√π h·ª£p</td></tr>';
        statsDiv.style.display = "none";
    } else {
        tbody.innerHTML = "";
        tbody.appendChild(fragment);
        
        const filterText = currentFilter === 'all' ? '' : 
                          currentFilter === 'ok' ? ' (Ch·ªâ hi·ªÉn th·ªã ƒë√£ tham gia)' :
                          currentFilter === 'pending' ? ' (Ch·ªâ hi·ªÉn th·ªã ƒë√£ upload ch∆∞a ki·ªÉm tra)' :
                          ' (Ch·ªâ hi·ªÉn th·ªã ch∆∞a tham gia)';
        
        statsDiv.innerHTML = `
            üìä T√¨m th·∫•y <strong>${count}</strong> k·∫øt qu·∫£${filterText}
            | ‚úÖ ƒê√£ tham gia: <strong>${okCount}</strong> 
            | ‚ùå Ch∆∞a tham gia: <strong>${missingCount}</strong>
            | ‚ùì ƒê√£ upload ch∆∞a ki·ªÉm tra: <strong>${pendingCount}</strong>
            ${count >= MAX_RENDER ? ` (Hi·ªÉn th·ªã t·ªëi ƒëa ${MAX_RENDER} k·∫øt qu·∫£)` : ''}
        `;
        statsDiv.style.display = "block";
    }
}

/* ===== SHOW MESSAGE ===== */
function showMessage(msg) {
    const tbody = document.getElementById("tbody");
    tbody.innerHTML = `<tr><td colspan="10" class="loading">${msg}</td></tr>`;
}

/* ===== SEARCH WITH DEBOUNCE ===== */
document.getElementById("searchInput").addEventListener("input", e => {
    clearTimeout(debounceTimer);
    const value = e.target.value;
    debounceTimer = setTimeout(() => render(value), 250);
});

/* ===== STATUS FILTER ===== */
document.querySelectorAll('input[name="statusFilter"]').forEach(radio => {
    radio.addEventListener('change', e => {
        currentFilter = e.target.value;
        const keyword = document.getElementById("searchInput").value;
        render(keyword);
    });
});

document.getElementById("searchInput").focus();

loadData();
</script>

</body>
</html>
