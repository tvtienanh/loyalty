<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tra c·ª©u Loyalty ‚Äì CT 2026</title>

<style>
    * { box-sizing: border-box; }
    body { 
        font-family: 'Segoe UI', Tahoma, Arial, sans-serif; 
        padding: 20px; 
        background: #f5f5f5;
        margin: 0;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    h2 { 
        color: #333; 
        margin-bottom: 20px;
        font-size: 24px;
    }
    
    .search-box {
        margin-bottom: 20px;
    }
    
    input { 
        width: 100%;
        max-width: 500px;
        padding: 12px 16px; 
        font-size: 15px;
        border: 2px solid #ddd;
        border-radius: 6px;
        transition: border-color 0.3s;
    }
    
    input:focus {
        outline: none;
        border-color: #4CAF50;
    }
    
    .stats {
        margin: 15px 0;
        padding: 12px;
        background: #e3f2fd;
        border-radius: 6px;
        font-size: 14px;
        color: #1976d2;
    }
    
    .table-wrapper {
        overflow-x: auto;
        margin-top: 20px;
    }
    
    table { 
        border-collapse: collapse; 
        width: 100%; 
        background: #fff;
        font-size: 13px;
    }
    
    th, td { 
        border: 1px solid #ddd; 
        padding: 10px 8px;
        text-align: left;
    }
    
    th { 
        background: #4CAF50;
        color: white;
        font-weight: 600;
        position: sticky; 
        top: 0;
        z-index: 10;
    }
    
    tr.ok-both { 
        background: #e8f5e9; 
    }
    
    tr.only-2026 { 
        background: #fff3e0; 
    }
    
    tr.only-2025 { 
        background: #ffebee; 
    }
    
    tr.pending-2026 {
        background: #fff9c4;
    }
    
    tr:hover {
        opacity: 0.85;
    }
    
    .status-ok {
        color: #2e7d32;
        font-weight: 600;
    }
    
    .status-new {
        color: #f57c00;
        font-weight: 600;
    }
    
    .status-missing {
        color: #c62828;
        font-weight: 600;
    }
    
    .status-pending {
        color: #f9a825;
        font-weight: 600;
    }
    
    .loading {
        text-align: center;
        padding: 40px;
        color: #666;
        font-size: 16px;
    }
    
    .no-results {
        text-align: center;
        padding: 40px;
        color: #999;
        font-style: italic;
    }
</style>
</head>

<body>

<div class="container">
    <h2>üîç Tra c·ª©u kh√°ch h√†ng Loyalty ‚Äì Ki·ªÉm tra CT 2026</h2>
    
    <div class="search-box">
        <input 
            id="searchInput" 
            placeholder="Nh·∫≠p M√£ KH / T√™n kh√°ch h√†ng / SƒêT / T√™n TDV ƒë·ªÉ t√¨m ki·∫øm..."
            autocomplete="off"
        >
    </div>
    
    <div id="stats" class="stats" style="display:none;"></div>
    
    <div class="table-wrapper">
        <table>
            <thead>
                <tr>
                    <th>M√£ KH</th>
                    <th>Kh√°ch h√†ng</th>
                    <th>T·ªânh</th>
                    <th>SƒêT</th>
                    <th>TDV</th>
                    <th>Team k√Ω 2025</th>
                    <th>Team k√Ω 2026</th>
                    <th>ƒêƒÉng k√Ω th√†nh c√¥ng</th>
                    <th>Ghi ch√∫</th>
                    <th>Tr·∫°ng th√°i 2026</th>
                </tr>
            </thead>
            <tbody id="tbody">
                <tr>
                    <td colspan="10" class="loading">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu...</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
const NEW_URL = "https://docs.google.com/spreadsheets/d/14dZ70xuUlYskJHGLfF4dI_lY_V8vsqJfAJ-Dlo_DdrU/gviz/tq?tqx=out:json&sheet=new_data";
const OLD_URL = "https://docs.google.com/spreadsheets/d/14dZ70xuUlYskJHGLfF4dI_lY_V8vsqJfAJ-Dlo_DdrU/gviz/tq?tqx=out:json&sheet=original_data";

const MAX_RENDER = 1000;

// L∆∞u ri√™ng bi·ªát, KH√îNG merge
let newDataMap = {};      // Key: M√£ KH, Value: full record from new_data
let oldDataMap = {};      // Key: M√£ KH, Value: full record from original_data
let allMaKH = new Set();  // T·∫•t c·∫£ M√£ KH t·ª´ c·∫£ 2 ngu·ªìn
let searchArray = [];     // Array ƒë·ªÉ search

let debounceTimer;
let isLoading = true;

/* ===== PARSE GOOGLE VISUALIZATION JSON ===== */
function parseGViz(text) {
    const jsonText = text.substring(47, text.length - 2);
    return JSON.parse(jsonText);
}

function rowToObject(cols, row) {
    const obj = {};
    cols.forEach((col, i) => {
        const cell = row.c[i];
        let value = "";
        
        if (cell !== null && cell !== undefined) {
            if (cell.v !== null && cell.v !== undefined) {
                value = cell.v;
            } else if (cell.f !== null && cell.f !== undefined) {
                value = cell.f;
            }
        }
        
        obj[col.label] = String(value).trim();
    });
    return obj;
}

/* ===== LOAD DATA ===== */
async function loadData() {
    try {
        const [newResponse, oldResponse] = await Promise.all([
            fetch(NEW_URL),
            fetch(OLD_URL)
        ]);

        const newText = await newResponse.text();
        const oldText = await oldResponse.text();

        const newJson = parseGViz(newText);
        const oldJson = parseGViz(oldText);

        console.log("=== COLUMNS ===");
        console.log("New data columns:", newJson.table.cols.map(c => c.label));
        console.log("Old data columns:", oldJson.table.cols.map(c => c.label));

        // Load new_data - GI·ªÆ NGUY√äN, KH√îNG MERGE
        console.log("Loading new_data...");
        newJson.table.rows.forEach(row => {
            const obj = rowToObject(newJson.table.cols, row);
            const maKH = obj["M√É KH"];
            
            if (maKH) {
                newDataMap[maKH] = obj;
                allMaKH.add(maKH);
            }
        });

        console.log("new_data loaded:", Object.keys(newDataMap).length, "records");

        // Load original_data - GI·ªÆ NGUY√äN, KH√îNG MERGE
        console.log("Loading original_data...");
        oldJson.table.rows.forEach(row => {
            const obj = rowToObject(oldJson.table.cols, row);
            const maKH = obj["M√É KH"];
            
            if (maKH) {
                oldDataMap[maKH] = obj;
                allMaKH.add(maKH);
            }
        });

        console.log("original_data loaded:", Object.keys(oldDataMap).length, "records");
        console.log("Total unique M√£ KH:", allMaKH.size);

        // T·∫°o search array t·ª´ T·∫§T C·∫¢ M√£ KH
        console.log("Building search array...");
        searchArray = Array.from(allMaKH).map(maKH => {
            const newRec = newDataMap[maKH];
            const oldRec = oldDataMap[maKH];

            // L·∫•y th√¥ng tin t·ª´ new_data n·∫øu c√≥, kh√¥ng th√¨ t·ª´ old_data
            const record = {
                maKH: maKH,
                kh: (newRec && newRec["KH"]) || (oldRec && oldRec["KH"]) || "",
                tinh: (newRec && newRec["T·ªàNH"]) || "",
                sdt: (newRec && newRec["SƒêT"]) || (oldRec && oldRec["SƒêT"]) || "",
                tdv: (newRec && newRec["TDV"]) || (oldRec && oldRec["TDV"]) || "",
                team2025: (newRec && newRec["TEAM ƒê√É K√ù 2025"]) || (oldRec && oldRec["TEAM"]) || "",
                team2026: (newRec && newRec["TEAM ƒê√É K√ù 2026"]) || "",
                dangKy: (newRec && newRec["ƒêƒÇNG K√ù TH√ÄNH C√îNG"]) || "",
                noteHinh: (newRec && newRec["NOTE H√åNH ·∫¢NH"]) || "",
                thongTinSai: (newRec && newRec["TH√îNG TIN SAI"]) || "",
                inNew: !!newRec,
                inOld: !!oldRec
            };

            // T·∫°o search string
            const searchFields = [
                record.maKH,
                record.kh,
                record.sdt,
                record.tdv,
                record.tinh
            ];
            record._search = searchFields.join(" ").toLowerCase();

            return record;
        });

        console.log("Search array built:", searchArray.length, "records");

        // Th·ªëng k√™
        const stats = {
            inBoth: searchArray.filter(r => r.inNew && r.inOld).length,
            onlyNew: searchArray.filter(r => r.inNew && !r.inOld).length,
            onlyOld: searchArray.filter(r => !r.inNew && r.inOld).length,
            ok2026: searchArray.filter(r => r.dangKy === "OK").length,
            cancel2026: searchArray.filter(r => r.dangKy === "Cancel").length,
            crosscheck2026: searchArray.filter(r => r.dangKy === "Cross-check").length
        };

        console.log("=== STATISTICS ===");
        console.log("Total records:", searchArray.length);
        console.log("In both 2025 & 2026:", stats.inBoth);
        console.log("Only in 2026 (new):", stats.onlyNew);
        console.log("Only in 2025 (not registered 2026):", stats.onlyOld);
        console.log("2026 status - OK:", stats.ok2026);
        console.log("2026 status - Cancel:", stats.cancel2026);
        console.log("2026 status - Cross-check:", stats.crosscheck2026);

        isLoading = false;
        showMessage(`‚úÖ ƒê√£ t·∫£i ${searchArray.length} kh√°ch h√†ng (New: ${Object.keys(newDataMap).length}, Old: ${Object.keys(oldDataMap).length}). H√£y nh·∫≠p t·ª´ kh√≥a ƒë·ªÉ t√¨m ki·∫øm.`);
        
    } catch (error) {
        isLoading = false;
        showMessage("‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i sau.");
        console.error("Load error:", error);
    }
}

/* ===== RENDER TABLE ===== */
function render(keyword = "") {
    const tbody = document.getElementById("tbody");
    const statsDiv = document.getElementById("stats");
    
    if (isLoading) {
        return;
    }

    if (!keyword.trim()) {
        tbody.innerHTML = '<tr><td colspan="10" class="no-results">üëÜ Nh·∫≠p t·ª´ kh√≥a ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm</td></tr>';
        statsDiv.style.display = "none";
        return;
    }

    const kw = keyword.toLowerCase().trim();
    const fragment = document.createDocumentFragment();
    let count = 0;
    
    // Counters
    let okBothCount = 0;
    let onlyNewCount = 0;
    let onlyOldCount = 0;
    let pendingCount = 0;

    for (const record of searchArray) {
        if (!record._search.includes(kw)) continue;

        const tr = document.createElement("tr");
        
        // X√°c ƒë·ªãnh tr·∫°ng th√°i
        let statusText = "";
        let statusClass = "";
        let rowClass = "";

        const dangKyStatus = record.dangKy.toUpperCase();

        if (record.inNew && record.inOld) {
            // C√≥ trong c·∫£ 2 nƒÉm
            if (dangKyStatus === "OK") {
                statusText = "‚úÖ ƒê√£ tham gia 2025 & 2026 (OK)";
                statusClass = "status-ok";
                rowClass = "ok-both";
                okBothCount++;
            } else if (dangKyStatus === "CANCEL") {
                statusText = "‚ö†Ô∏è ƒê√£ k√Ω 2025, 2026 Cancel";
                statusClass = "status-pending";
                rowClass = "pending-2026";
                pendingCount++;
            } else if (dangKyStatus === "CROSS-CHECK") {
                statusText = "‚è≥ ƒê√£ k√Ω 2025, 2026 Cross-check";
                statusClass = "status-pending";
                rowClass = "pending-2026";
                pendingCount++;
            } else {
                // C√≥ data nh∆∞ng ch∆∞a x√°c nh·∫≠n
                statusText = "‚è≥ ƒê√£ k√Ω 2025, 2026 ƒëang x·ª≠ l√Ω";
                statusClass = "status-pending";
                rowClass = "pending-2026";
                pendingCount++;
            }
        } else if (record.inNew && !record.inOld) {
            // Ch·ªâ c√≥ trong 2026 (kh√°ch m·ªõi)
            if (dangKyStatus === "OK") {
                statusText = "üÜï M·ªõi tham gia 2026 (OK)";
                statusClass = "status-new";
                rowClass = "only-2026";
                onlyNewCount++;
            } else if (dangKyStatus === "CANCEL") {
                statusText = "üÜï M·ªõi 2026 nh∆∞ng Cancel";
                statusClass = "status-pending";
                rowClass = "pending-2026";
                pendingCount++;
            } else if (dangKyStatus === "CROSS-CHECK") {
                statusText = "üÜï M·ªõi 2026, Cross-check";
                statusClass = "status-pending";
                rowClass = "pending-2026";
                pendingCount++;
            } else {
                statusText = "üÜï M·ªõi 2026, ƒëang x·ª≠ l√Ω";
                statusClass = "status-new";
                rowClass = "only-2026";
                onlyNewCount++;
            }
        } else {
            // Ch·ªâ c√≥ trong 2025, ch∆∞a ƒëƒÉng k√Ω 2026
            statusText = "‚ùå Ch·ªâ c√≥ 2025, ch∆∞a ƒëƒÉng k√Ω 2026";
            statusClass = "status-missing";
            rowClass = "only-2025";
            onlyOldCount++;
        }

        tr.className = rowClass;

        // Ghi ch√∫
        const notes = [];
        if (record.noteHinh) notes.push(record.noteHinh);
        if (record.thongTinSai) notes.push(record.thongTinSai);
        const note = notes.join(" | ");

        tr.innerHTML = `
            <td>${record.maKH}</td>
            <td>${record.kh}</td>
            <td>${record.tinh}</td>
            <td>${record.sdt}</td>
            <td>${record.tdv}</td>
            <td>${record.team2025}</td>
            <td>${record.team2026}</td>
            <td>${record.dangKy}</td>
            <td>${note}</td>
            <td class="${statusClass}">${statusText}</td>
        `;

        fragment.appendChild(tr);
        count++;
        
        if (count >= MAX_RENDER) break;
    }

    if (count === 0) {
        tbody.innerHTML = '<tr><td colspan="10" class="no-results">üîç Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√π h·ª£p</td></tr>';
        statsDiv.style.display = "none";
    } else {
        tbody.innerHTML = "";
        tbody.appendChild(fragment);
        
        statsDiv.innerHTML = `
            üìä T√¨m th·∫•y <strong>${count}</strong> k·∫øt qu·∫£ 
            | ‚úÖ OK c·∫£ 2 nƒÉm: <strong>${okBothCount}</strong> 
            | üÜï M·ªõi 2026: <strong>${onlyNewCount}</strong>
            | ‚ùå Ch·ªâ 2025: <strong>${onlyOldCount}</strong>
            | ‚è≥ Pending: <strong>${pendingCount}</strong>
            ${count >= MAX_RENDER ? ` (Hi·ªÉn th·ªã t·ªëi ƒëa ${MAX_RENDER})` : ''}
        `;
        statsDiv.style.display = "block";
    }
}

/* ===== SHOW MESSAGE ===== */
function showMessage(msg) {
    const tbody = document.getElementById("tbody");
    tbody.innerHTML = `<tr><td colspan="10" class="loading">${msg}</td></tr>`;
}

/* ===== SEARCH WITH DEBOUNCE ===== */
document.getElementById("searchInput").addEventListener("input", e => {
    clearTimeout(debounceTimer);
    const value = e.target.value;
    debounceTimer = setTimeout(() => render(value), 250);
});

// Auto focus on search input
document.getElementById("searchInput").focus();

// Load data on page load
loadData();
</script>

</body>
</html>
